# <!-- 프로세스 , 데몬 , 서비스 -->

# 프로세스 , 데몬 , 서비스

### 리눅스나 유닉스에 익숙하지 않는 사용자는 조금 생소한 용어 일수 있지만 중요한 용어들이므로 꼼꼼히 살펴보기 바란다.

# 프로세스

### 프로세스(Process)를 정의하면 '하드디스크에 저장된 실행 코드(프로그램)가 메모리에 로딩되어 활성화 된것'

### 프로세스와 관련된 필수 개념 및 용어는 다음과 같다.

## 포그라운드 프로세스

### 포그라운드 프로세스(Foregroud Process)는 실행하면 화면에 나타나서 사용자와 상호 작용하는 프로세스를 말한다. 화면에서 보이는 프로세스라고 생각하자 (chrome , firefox)

## 백그라운드 프로세스

### 백그라운드 프레세스(Background Process)는 실행은 되었지만 화면에는 나타나지 않고 뒤에서 실행되는 프로세스이다.

### 바이스러 백신 , 서버 데몬 등을 의미한다.

## 프로세스 번호

### 메모리에 로딩되어 활성화 된 프로세스를 구분하려면 각각의 고유 번호가 필요하다. 이렇게 각각의 프로세스에 할당된 고유 번호를 프로세스 번호라고 한다. 프로세스 번호가 필요한 이유는 활성화된 프로세스를 메모리에서 강제로 제거하려면 프로세스 번호를 사용해야 하기 때문이다.

## 작업 번호

### 현재 실행되는 백그라운드 프로세스의 순차 번호를 의미한다.

## 부모 프로세스와 자식 프로세스

### 모든 프로세스는 혼자서 독립적으로 실행되는 것이 아니라 부모 프로세스의 하위에 종속되어 실행된다. 예를 들어 Firefox 같은 경우 X 윈도 프로세스가 구동된 상태에서 실행되어야하므로 , x 윈도는 fIREFOX의 부모 프로세스이며 Firefox 는 X 윈도의 자식 프로세스라고 부른다.

---

### 다음은 프로세스와 관련된 주요 명령어이다.

| 명령어 |                                                                                                  내용                                                                                                   |
| :----: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|   ps   |               현재 프로세스의 상태를 확인하는 명령어로, 많은 옵션과 함께 사용할 수 있다 이 책에서는 프로세스의 번호 및 상태를 확인할 때는 'ps -ef \| grep 프로세스이름' 명령을 사용한다.                |
|  kill  | 프로세스를 강제로 종료하는 명령어로, -9 옵션과 함께 사용하면 무조건 프로세스가 종료된다. 예를 들어 응답하지 않고 무한 루프를 도는 프로세스는 'kill -9 프로세스번호'명령을 실행해 강제 종료시킬 수 있다. |
| pstree |                                                                      부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여준다.                                                                       |

|   명령어    |                                           내용                                           |
| :---------: | :--------------------------------------------------------------------------------------: |
|    jobs     | 현재 백그라운드로 가동중인 프로세스 확인할 수 있으며 제일 앞에 나오는 것이 작업번호이다. |
| fg 작업번호 |           백그라운에서 가동중인 프로세스를 포그라운드 프로세스로 만들 수 있다.           |
|     bg      |                  잠시 중지된 프로세스를 백그라운드 프로세스로 실행시킴                   |

### 프로세스 실행 시 바로 백그라운 프로세스로 만들 수 있다. 즉, 모든 명령어 뒤에 &를 붙이면 자동으로 백그라운드로 실행된다.

### 그런데 사용시 주의 점이 있다.

### firefox, gedit 등은 별도의 창에서 실행되므로 백그라운드로 실행해도 아무 문제가 없다. 또 xz , bzip2 , gzip 같은 압축 프로그램으로 대용량 압축 파일을 만든다면 시간이 오래 걸릴 텐데 이럴 때 백그라운드 프로세스로 실행하면 유용할 것이다.

## 하지만 vi 에디터와 같이 현재 터미널에서 입출력해야 하는 프로세스를 백그라운드 프로세스로 실행하는 것은 아무런 의미가 없다. 즉 'vi 파일이름 &' 명령을 실행해도 입출력할 수 없으므로 무의미 하다는 뜻이다.

<br>

# <!-- 서비스 -->

# 서비스

### 데몬(daemon)이라고 부르는 서비스(service)는 서버 프로세스를 말한다.

### 즉 서비스는 웹 서버, 네임 서버 , DB 서버 등의 프로세스를 지칭한다. 또 웹 서버 데몬 , 네임 서버 데몬 등으로 부르기도 한다.

### 서비스는 눈에 보이지 않지만 현재 시스템에서 동작중인 프로세스이므로 백그라운드 프로세스의 일종이라고 할 수 있다.

### 바로 이어서 나오는 서버 유형과 밀접한 관련이 있으므로 우선은 '서비스 = 데몬 = 서버 프로세스' 정도로 이해만 해두자

<br>

# <!-- 서비스와 소켓 -->

# 서비스와 소켓

### 서비스는 평상시에도 늘 가동하는 프로세스며, 소켓(socket)은 필요할 때만 동작하는 서버 프로세스다. 서비스와 소켓은 systemd 라는 서비스 매니저 프로그램으로 작동시키거나 관리한다.

### 이전에는 최상의 프로세스인 init 프로세스가 서비스를 직접 관리하는 방식이었으나, 요즘에는 systemd 가 서비스 대부분을 관리한다. systemd와 관련된 세부 내용은 http://docs.fedoraproject.org/en-US/quick-docs/understanding-and-administering-systemd/ 주소를 참조하자

# <!-- 서비스 -->

# 서비스

### 서비스의 특징을 살펴보자

- 시스템과 독자적으로 구동 및 제공되는 프로세스를 말한다. 웹서버(httd), DB서버(mysql), FTP 서버(vsfpd) 등을 예로 들 수 있다.
- 실행 및 종료는 대개 'systemctl start/stop/restart 서비스이름' 명령으로 사용된다. 예를 들어 웹 서버는 systemctl start httpd 명령으로 구동한다.
- 서비스의 실행 스크립트 파일은 '/usr/lib/systemd/system/' 디렉터리에 '서비스이름.service'라는 이름으로 확인할 수 있다 예를 들어 Cron 서비스는 crond.service 라는 이름의 파일로 존재한다.
- 부팅과 동시에 서비스의 자동 실행 여부를 지정할 수 있는데 터미널에서 'systemctl list-unit-files' 명령을 실행하면 현재 사용(enabled)과 사용 안함(disabled)을 확인할 수 있다.
- systemctl list-unit-files 명령의 상태 (STATE)가 static으로 설정된 것은 사용/사용 안 함 으로 설정할 수 없으며, 다른 서비스나 소켓에 의존해서 실행된다. 그 외의 generated , transient 등은 특별히 신경을 쓰지 않아도 된다.


|                  명령어                  |                            내용                            |
| :--------------------------------------: | :--------------------------------------------------------: |
| systemctl start/stop/restart 서비스 이름 |                  서비스 시작/중지/재시작                   |
|       systemctl status 서비스이름        |                      서비스 상태 확인                      |
|         systemctl enable/disable         |                 서비스 사용/사용안함 설정                  |
|        systemctl list-unit-files         | 현재 사용(enabled)과 사용 안함(disabled)을 확인할 수 있다. |

|        파일 위치         |               내용               |
| :----------------------: | :------------------------------: |
| /usr/lib/systemd/system/*.service | 서비스의 실행 스크립트 파일 확인 |


# <!-- 소켓 -->
# 소켓
### 소켓의 특징을 살펴보자
- 서비스는 항상 가동되지만 소켓은 외부에서 특정 서비스를 요청할 경우 systemd 가 구동시킨다. 그리고 요청이 끝나면 소켓도 종료된다.
- 그래서 소켓으로 설정된 서비스를 요청할 때 처음 연결되는 시간은 앞에서 설정한 서비스에 비해 약간 더 걸릴 수 있다. 왜냐하면 systemd 가 서비스를 새로 구동하는 데 시간이 소요되기 때문이다. 이와 같은 소켓의 대표적인 예로 텔넷 서버를 들 수 있다.
- 소켓과 관련된 스크립트 파일은 '/usr/lib/systemd/system/' 디렉터리에 '소켓이름.socket' 이라는 이름으로 존재한다

|        파일 위치         |               내용               |
| :----------------------: | :------------------------------: |
| /usr/lib/systemd/system/*.socket | 소켓과 관련된 실행 스크립트 파일 확인 |

## <참조> xinetd 데몬
### 예전 CentOS에서는 소켓과 비슷한 개념으로 XINETD 데몬이 주로 사용되었으며 CentOS 8 도 xinetd 데몬을 지원한다. 하지만 많은 서비스가 xinetd 대신 소켓으로 사용된다.

